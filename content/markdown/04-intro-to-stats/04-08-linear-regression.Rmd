---
output:
  pdf_document: default
  html_document: default
---
# Linear Regression
**Author:** Cole Brookson
**Date:** 29 August 2022

<em>What factors influence bison mass in a restored ecosystem?</em>

One of the first chapters to a book on causal inference that I have recently read is entitled "All you need is regression". I thought this was an accurate way to start this section, because that statement is true! While we cannot cover all the theory of linear regression here, it is genuinely the case that nearly all classical frequentist statistical methods are simply a version of linear regression. A t-test? Actually just linear regression. ANOVA? Yup, also linear regression. Machine learning?? Many types of it are in fact just regression!

So why then, you may ask, did we learn about t-tests before we learned about linear regression in stats class? Well, it turns out that as with almost all quantitative methods discussed in this section, linear regression is frightfully easy to implement, but actually not so simple "under the hood." 

However, getting an intuitive understanding of the basics is very much possible and highly encouraged. Linear regression is probably the most fundamental of all topics you may learn in statistics, and it's worth thinking about it carefully. To be clear, you will likely re-visit this topic many times, likely over the course of years, adding and refreshing pieces of information that will eventually develop into a solid understanding. here, we attempt only to provide a brief introduction to the basics. 

## What is Regression?

A gross simplification of the process of linear regression would be that if we have a series of points between two continuous variables, we want to find a straight line that goes through as many of those points as possible. 

What does it mean to do such a thing? Well, let's start with reminding ourselves, mathematically, what a line is. A straight line is defined by the equation $$ y = mx + b$$ where $b$ is the y-intercept, $m$ is the slope of the line, and $x$ and $y$ are data values. This means that given a point on the x-axis, $x$, a slope $m$, and a y-intercept $b$, we can find the value $y$ that denotes the y-axis value that corresponds to the x-axis value $x$. 

When we talk about linear regression, we'll probably want to discuss this equation in a slightly alterred form: $$y = \beta_0 + \beta_1 x_1$$. We'll discuss what these terms mean in a moment but they relate exactly to a y-intercept ($\beta_0$), a slope ($\beta_1$) and an x-value. 

## Ordinary Least Squares (OLS)

We mentioned above we're putting a line through some points as best we can. But how do we define this "best as we can"? Well, the version of "as best we can" that will be addressed here is the method of least squares. If we imagine a scatter of plots like this: 

```{r, echo = FALSE, warning = FALSE}
x = c(1:100)
y = rep(NA, 100)
for(i in 1:100) {
  y[i] = 1.3 * x[i] + 10 + rnorm(1, mean = 0, sd = 23)
}

df = data.frame(
  x = x, y = y
)

library(tidyverse)
library(ggthemes)
ggplot(df) + 
  geom_point(aes(x = x, y = y), fill = "red", colour = "black", shape = 21, 
             size = 3) + 
  ggthemes::theme_base()
```

It's clear that we can't actually make our line go <em>directly</em> through very many of them, but perhaps we can figure out some way to make the line <em> as close to as many points as possible</em>. We'll do that by imagining we draw a line at random, and calculate the distance between every single point and the line itself. These are called <strong>residuals</strong>. Then we'll square each one, and take the sum of all those squares. 

You might ask, why square it? The short answer to that question is that squaring it makes a large number of mathematical tools available to us. 

It now follows somewhat logically that we want to find a value for the slope of our line, $\beta_1$ that <strong>minimizes</strong> this sum of the squared residuals. What we are doing here is actually a process called <em>estimation</em> wherein we choose some method that allows us to compare candidate values for $\beta_1$ with other values. Ordinary Least Squares is actually just a specific version of Maximum Likelihood Estimation, which we'll discuss below. 

## Linear Model

As in our previous work, we will certainly NOT (!!!!) just jump into writing code, as that's the best way to ensure a poorly done analysis. First, we have our question. Let's frame it as a hypothesis. It seems logical here to state that we think temperature will positively vary with ice cover. So a null hypothesis may be that <em> there is no relationship between air temperature and ice cover </em>. We have decided we want to use linear regression to tackle this challenge, so consider the assumptions of the method: 

1. Linearity - we assume the relationship between our two variables, $X$ and $Y$ is linear

2. Homoskedacity - we assume the variance of the residual is the same for any value of $X$

3. Normality - We assume that for any fixed value of $X$, the errors of $Y$ normally distributed

4. Randomness - We also assume that samples were collected at random

5. Independence - All errors are independent

If assumptions 1-3 are violated, then we can may be able to use some sort of transformation on our response variable to deal with the problem. 

### Small example 

Let's now get our hands dirty with a bit of an example, a very small one, that we'll go all the way through and then delve into some details in the next example. Very generally, we can think of the process of doing regression as falling into a few steps: 

1) Inspect our data 

2) Perform the regression

3) Assess our assumptions (post-hoc)

4) Inspect our results

5) Interpret & Visualize


Here are the data we will start with: 

```{r}
# set seed -- see section on this in the probability section
set.seed(1234)

x = c(1:100)
y = rep(NA, 100)
for(i in 1:100) {
  y[i] = 1.3 * x[i] + 10 + rnorm(1, mean = 0, sd = 23)
}

df = data.frame(
  x = x, y = y
)

head(df)
```

Often it's true when doing regression modelling that it's easier to do our diagnostics of assumptions <em>after</em> we actually fit the model itself as some more simple tools will become available to us. So, let's start with fitting the model. As we mentioned before, R makes it dead simple to do a linear regression in R with the <code>stats::lm()</code> function. 

```{r}
mod <- stats::lm(y ~ x, data = df)
```

That's it! Now let's begin seeing if what our model did was "correct". First, we assumed linearly. We can double check this with a simple scatter plot: 

```{r}
library(tidyverse)
library(ggthemes)
ggplot(df) + 
  geom_point(aes(x = x, y = y), fill = "red", colour = "black", shape = 21, 
             size = 3) + 
  ggthemes::theme_base()
```

This looks sufficiently linear for our purposes. However, we can actually check all of our assumptions visually at once by using the diagnostic plots that are created by simply plotting our model object: 

```{r}
par(mfrow = c(2,2)) # this ensures all the plots show up at once
plot(mod)
```

So we have four plots here. 

The first plot is the <strong>Residuals vs. Fitted</strong>. This allows us to check the linear relationship assumption. If the red line approximately follows the grey dashed line and there are no distinct patterns, then the variables are linearly related. 

Second is the <strong>Normal QQ</strong>, and we interpret this the same way we interpreted QQ plots previously. If the points follow the line and don't deviate significantly, then the residuals here are normally distributed. 

Third is the <strong>Spread-Location</strong>, which tests the homogeneity of variance in the residuals (our homoskedasticity). Again, we want to see a horizontal red line with "shotgun" (aka randomly spread) points. 

The last is the <strong>Residuals vs. Leverage</strong>. We don't need to look at this plot too carefully right now, but in brief, it's used to identify points having too strong of an influence on the outcome of the analysis. 

Okay so it looks like all our assumptions are satisfied! Let's take a look at our results: 

```{r}
summary(mod)
```

Let's break down each of the components here: 

1. <strong>Call</strong> -- this is the function we used in our model. So to recall, what we're showing here is the that we've regressed <code>y ~ x</code> which we would say as "y regressed against x" or "y regressed with x". 

2. <strong>Residuals</strong> -- These are the residuals. Recall that a <em>residual</em> is the distance from a single point to the regression line at the same x-location. Here's a visual of that: 

```{r}
ggplot(data = df, mapping = aes(x = x, y = y)) + 
  geom_smooth(method = "lm", formula = y ~ x, colour = "red", se = FALSE) +
  ggthemes::theme_base() +
  geom_point(data = df %>% dplyr::filter(
    x %in% c(22, 45, 89)
  ), size = 3, colour = "black", fill = "purple", shape = 21) +
  geom_line(data = data.frame(x = c(22, 22), y = c(
    predict(mod, data.frame(x = 22)), df$y[which(df$x == 22)]
  )), aes(x = x, y = y)) + 
  geom_line(data = data.frame(x = c(45, 45), y = c(
    predict(mod, data.frame(x = 45)), df$y[which(df$x == 45)]
  )), aes(x = x, y = y)) + 
  geom_line(data = data.frame(x = c(89, 89), y = c(
    predict(mod, data.frame(x = 89)), df$y[which(df$x == 89)]
  )), aes(x = x, y = y)) 
```

Each of the lines here going from the points to the the regression line itself are "residuals", or "residual error", the amount of "error" the linear model produces in it's prediction for a given x-value.

Ok back to our <code>summary()</code> call: 

```{r}
summary(mod)
```

the residuals here, by definition, have a mean of zero, and a "perfecty" minimized set of residuals would mean that the median value is zero, which will not really happen, but we want the median to be as close to zero as possible. We also want our minimum and maximum values to be approximately equal in magnitude. 

3. <strong> Coefficients </strong> -- Possibly the part that we'll look at the most, these values are here shown as representing $\beta_0$ and $\beta_1$. So the intercept is the actual y-intecept (remember that $\beta_0$ is the y-intercept), and the $\beta_1$ is the estimate of the coefficient on $x$. We assess whether or not a particular predictor variable is significantly associated with the outcome variable via the "Pr(>|t|)" statement of the p-value. For our purposes, this will be useful, but I encourage you to interpret these p-values with caution, especially when there are multiple variables. 

For our consideration, we take the <em>Estimate</em> as the actual estimated value for the $\beta$s and then the standard errors (SE), which define accuracy of beta coefficients. A larger SE indicates a less certain beta estimate. We then see the t-statistic and the associated p-value, which speak to the statistical significance of the beta coefficients.

We have to recall that for our regression, we are using the $H_0$ that the estimate is zero, which denotes no effect from said coefficient. If any coefficient has a p-value < 0.05, we can infer that the estimate is significantly different from zero. However, this says nothing about the <em>strength</em> of that interaction. 
 
If we cared to construct a confidence interval around our beta values, we could do so with $\beta +/- 1.96 * SE_{\beta}$, which would give us our 95% CI. 

4. <strong>Model Accuracy</strong> -- We see a number of measures at the bottom, starting with the Residual Standard Error, which contain information about how well our model has fit. 

Starting with the <strong> Residual Standard Error (RSE)</strong>, which essentially represents the average variation of the data points from the fitted regression line. It stands to reason that we want this value to be as small as possible. It comes in handy most when comparing multiple models. Say, for example, we had some other variable $z$ that we think may explain $y$, we could compare the two models $y ~ x$ and $y ~ z$ and see which model has a smaller RSE. This is not the best way to compare models, but it's a good start.

We then see two measures of $R^2$, which is a measure of how well the model fits the data. Specifically, the measure gives the proportion of information (i.e. variation) in the data that can be explained by the model. In general, it's preferred to use the "Adjusted R-squared" as when we add more predictors into our model, the calculation of the Adjusted R-squared will account for that. 

We also see the <em>F-statistic</em> which is a rough estimate of whether there is a relationship between our predictor and response variables or not. The simple interpretation is that the further the F-statistic is from 1, the stronger the relationship between our predictor and response variables.  

<hr>

Okay so we have all this output. What do we do with it?? Well, that depends on how we've formulated our hypothesis, but let's say that we've stated our hypothesis to be that we think there's a significantly non-zero relationship between x and y. Well we already have our answer in this case! If we look back at our <code>summary()</code> table, then we can see that our t-statistic and p-value are already given. We can see we have a significant result, which says we can reject the null hypothesis that there was no relationship (i.e. $\beta_x = 0$).

## Categorical Variables

Let's move to a real ecological example: <strong>How does adult size differ between male and female bison?</strong> 

This is a good question to introduce the idea of categorical variables in a linear regression. We'll use some data here on bison sizes, and we're curious to estimate how much bigger males are than females. This is a categorical variable! We're no longer regressing just one continuous variable against another. Ok first, let's do some data manipulation. 

### Data Preparation

We are dealing with data on bison from the herd at Konza Prairie Biological Station LTER (KPBS) in Kansas. We happen to just be interested in adult bison, but there's not a measure for that, so we'll make one. A quick Google search tells us bison become sexually mature at 2-3 years of age, so we'll filter our data so that we only keep animals older than 4, to make sure we're comparing grown adults who've finished adolescence. 

```{r}
library(lterdatasampler)

# load in the bison data
bison <- lterdatasampler::knz_bison 

# make an age variable, and filter it
bison <- bison %>% 
  dplyr::mutate(age = rec_year - animal_yob) %>% 
  dplyr::filter(age > 4)
```

These both look pretty normal, and while there seems to be a wider variance in the male weights than female, it looks not too different, and we'll check that to be sure in our diagnostic plots. 

### Model Fit & Diagnostics

So now let's fit our model, and talk about the assumptions and the output.

```{r}
mod <- lm(animal_weight ~ animal_sex, data = bison)
```

We'll do some diagnostics first: 

```{r}
par(mfrow = c(2,2)) # this ensures all the plots show up at once
plot(mod)
```

Our linearity assumption is tested by our first plot, the Residuals vs. Fitted plot, and our goal is to have a straight red line, which we do. Additionally, we can check out homoskedasticity with this plot, or with the third Scale-Location plot. We want to see an equivalent vertical spread of the points between the two groups, which we roughly do, though we can see the right side is slightly more spread out than the left, but not enough to cause us trouble. The normality of residuals we can see here in our second plot, the QQ plot. We want the points to fall along the line, with few deviations. This plot looks great. Those are our three big ones taken care of, and randomness and independence we assume from the sampling procedure. 

### Interpreation 

Ok, so the important part. Interpretation. Before we even <em>look</em> at the output let's think about this mathematically. Our regression equation here we can think of as this: $$\widehat{weight} = \beta_0 + \beta_1 Sex$$. (Note here that we're using the hat on top of "weight" to indicate it's a predicted not measured value.) So recall that $\beta_0$ is the intercept, so if we find that, and we estimate our $\beta_1$ through regression, we should be able to predict the weight for any new bison that joins the herd, by taking $\beta_0$ and adding $\beta_1$ multiplied by the sex of the new bison. 

But wait. How would we multiply a value "male" or "female". Well, the thing is we can't, and we don't have to! Instead, we use the very clever trick of <strong>indicator variables</strong>, where we assign a unique number to each of the possible categories in our categorical variable. Since we only have two levels in this example, we will use a 0 and 1 scheme. So what we will do, or rather what R will do under the hood, is use a function to indicate whether or not a given animal is a female or not, like this: 

$$I_F = 
\begin{cases}
1 & \text{if animal is female}\\
0 & \text{otherwise}\\
\end{cases}
$$ 

Where $I_F$ just stands for Indicator, with the subscript F denoting that we're talking about females. 

So we actually just end up with our regression equation looking like this: $$\widehat{weight} = \beta_0 + \beta_1 I_F$$

where to predict an animal's weight, we'll multiply $\beta_1$ by the appropriate value given by the indicator function above - 0 or 1. 

Now that we've walked through this, let's look at the summary and discuss: 

```{r}
summary(mod)
```

So knowing that the indicator function is using females as 0 and males as 1 (we can see this because the coefficient after the intercept is <code>animal_sexM</code>), what would the weight of a female bison be, given no other information?  Well, the formula would be: $$\widehat{weight}_F = \beta_0 + \beta_1 I_F$$ And the indicator function if we look above will be $$I_F = 0$$ so the formula simplifies to: $$\widehat{weight}_F = \beta_0 + \beta_1 * 0$$ and therefore $$\widehat{weight}_F = \beta_0 $$, which is  1001.253.

What about for males? Well, the formula would be: $$\widehat{weight}_M = \beta_0 + \beta_1 I_F$$ And in this case $I_F = 1$ so, that would be after plugging in the values $$\widehat{weight}_M  = 1001.253 + 567.046$$ or in R: 

```{r}
1001.25 + 567.046
```

## Multiple Predictor Variables

The process of adding more variables as possible predictors is a simple one technically, but requires that we think more carefully about the model output. In this case the principle of <a href="https://en.wikipedia.org/wiki/Occam%27s_razor">Occam's Razor</a> or the law of parsimony applies, wherein, it is generally true that we are looking for the most parsimonious solution. That is, we want to identify a model which provides us the most explanatory power with respect to the data, while minimizing the number of features. So, when performing modeling exercises routed in rigorous hypothesis testing, we never add extraneous variables we don't have a good reason to add. And we always attempt to only keep variables in the model which sufficiently add explanatory power. A linear regression with multiple predictor variables is often called multiple regression.

Let's use an example. We've already used the bison example above, so let's stick with that. Say that we hypothesized males are bigger than females (a reasonable assumption), but also that the size of individuals over all has gone down through time. While this specific herd is managed and protected, this type of hypothesis may make sense if considering a harvested population, as often hunting removes the largest individuals from a population. We fit our model above and could have determined that indeed males are larger than females in a meaningful sense. Perhaps we now wanted to understand if adding time to our model improved the "fit". That is, if more variation in the data are explained by adding this additional parameter. 

Let's try it! So we are now using a slightly altered equation, since we'll treat time as continuous, our model equation for a predicted weight of an individual will look like: $$\widehat{weight} = \beta_0 + \beta_1 I_F + \beta_2*\text{year}$$. We may be hypothesize that $\beta_2$ will be significantly lower than zero, indicating that as time increases, the effect on predicted weight will be that of a decreased weight. 

First, let's look at the structure of the data and make sure year is numeric/integer-typed:

```{r}
str(bison)
```

We want the <code>rec_year</code> variable, so that looks good. Now let's look at the spread of those data (i.e. how many years are represented):

```{r}
summary(bison$rec_year)
```

Okay, so we have 15 years of data. Let's move on to the model:

```{r}
mod_mr <- lm(animal_weight ~ animal_sex + rec_year,
          data = bison)
```

And we'll do our diagnostic plotting: 

```{r}
par(mfrow = c(2,2)) # this ensures all the plots show up at once
plot(mod_mr)
```

These look sufficiently satisfactory. Now for the output: 

```{r}
summary(mod_mr)
```

Okay! So it looks as though we might have been wrong! It appears as though the size of animals may be <em>increasing</em> through time. Technically we've been given a significant p-value on the coefficient of <code>rec_year</code> but the estimate isn't high. 

### Model Objects & Subsetting

This is a good opportunity to discuss the actual object we create when we fit a linear model. We know we can call <code>summary</code> on our model object, but there are many other things we can do with it too. 

It's good to know first what structure the model object is:

```{r}
str(mod_mr)
```

This is a long set of things, and we'll not go through it all, but know first that any subset that has a <code>$</code> before it is accessible as such. For example: 

```{r}
mod_mr$coefficients
```

Will get us the coefficients. This is useful. We can also ask for the standard errors: 

```{r}
summary_ob <- summary(mod_mr)
summary_ob$coefficients[,2]
```

Other things we often want are the $R^2$ value: 

```{r}
summary_ob$adj.r.squared
```

We might also want the AIC (discussed below):

```{r}
stats::AIC(mod_mr)
```

Or the negative log-likelihood (also discussed below): 

```{r}
stats::logLik(mod_mr)
```

And there are a variety of other model components we might be interested in, the goal is to identify where they are in the fitted model object. Often other, perhaps more obscure values, are extracted easily enough, and the specific solution is easily Google-able. 

## Effect Estimation

A few things now about model comparison and effect estimation, which are both large subject areas. A quick and dirty way of estimating if the effect of this additional parameter is of importance is getting a 95% Confidence interval around the estimate. So we see from our summary table that the estimate is 0.9749. Well, a 95% confidence interval is easy enough to construct, as it is stated simply as $\mu \pm 1.96 * SE$ where SE is the standard error, which we see we already have in our output. So to calculate this in R, we can actually extract the coefficient value and standard error easily like so:

```{r}
estimate <- mod_mr$coefficients["rec_year"]
std_err <- summary_ob$coefficients[,2]["rec_year"]

```

If we wanted to print these values (i.e. say we were working in an R Markdown document and preparing a report for a class), we could print them into the text via:

```{r}
print(paste0("The coefficient estimate is: ", estimate, 
      " and the standard error is: ", std_err))
```

But back to our 95% CI, we can take those two valuesand perform a couple of multiplications:

```{r}
upper <- estimate + 1.96 * std_err
lower <- estimate - 1.96 * std_err
```

and then we would display our results as the estimate and then the 95% in brackets like so: 

```{r}
print(paste0("The estimate of the coefficient is ", estimate, " with a 95% 
             confidence interval of (", lower, ",", upper, ")"))
```

Or if we don't need quite so many digits and wanted to round it to three decimal places:

```{r}
print(paste0("The estimate of the coefficient is ", round(estimate, 3), " with a 95% confidence interval of (", round(lower, 3), ", ", round(upper, 3), ")"))
```

Now what does this tell us? Well, we're actually seeing that the 95% CI does not overlap zero, and so therefore we could interpret this as a "significant" effect. Note we haven't done a p-value based hypothesis test here, but this is a different and valid way to determine if an effect is of note. 

## Model Comparison & Evaluation

In the above section, we used a standard error from the model fit to calculate a 95% Confidence Interval around our estimate. This helped us understand if our estimate was very precise (i.e. if the magnitude on either side of the interval was large or small), but how can we tell this about our model as a whole? Back to this example with just one predictor variable:

```{r, echo=FALSE}
ggplot(df) + 
  geom_point(aes(x = x, y = y), fill = "red", colour = "black", shape = 21, 
             size = 3) + 
  geom_smooth(mapping = aes(x = x, y = y),
              method = "lm", formula = y ~ x, colour = "black", se = FALSE) +
  ggthemes::theme_base() 
```


The first thing we can do is look at our $R^2$ - the square of the correlation between our $x$ and $y$ variables, which for our bison example, we extracted above as: 

```{r}
summary(mod_mr)$adj.r.squared
```

### Likelihood Ratio Test (LRT)

Now let's think about comparing our models. For our bison model, we have two models. We'll re-fit them here for ease and simplicity: 

```{r}
mod1 <- lm(animal_weight ~ animal_sex, data = bison)
mod2 <- lm(animal_weight ~ animal_sex + rec_year, data = bison)
```

Recall at the beginning of the Multiple Regression section, we noted Occam's Razor, and that we are obliged to find and use the most parimonious model. Well we have two models, which is better in this regard.

We now have what is called "nested" models. The second model <code>mod2</code> is more complex, and our first model <code>mod1</code> is the nested model. Which one is better? Is it actually better, in terms of our understanding of the patterns underlying <code>animal_weight</code> to add the complexity in the second model? Well, to figure this out, we use the Likelihood Ratio Test. This test essentially tells us if it's beneficial to add parameters to our model or not. This test works by computing the negative log likelihood for each model, then comparing them using the chi-squared distribution. Here, $H_0$ is that the simpler, nested model is preferable and should be kept. Let's compute the negative log-liklihoods: 

```{r}
mod1_ll <- stats::logLik(mod1)
mod1_ll

mod2_ll <- stats::logLik(mod2)
mod2_ll
```

So we see they're different, and have different degrees of freedom. But which is better? Well, we then have to calculate a test statistic $$-2 * (\text{log-likelihood}(\text{model 1}) - \text{log-likelihood}(\text{model 2}))$$

```{r}
test_statistic <- -2 * (as.numeric(mod1_ll) - 
                          as.numeric(mod2_ll))
test_statistic
```

So now we need to use the probability function for the chi-squared distribution, which takes in $q$ and can return a probability for us. We also need to mass in the degrees of freedom, that is, the difference between the degrees of freedom for each of the models. We see that $df = 4$ and $df = 3$ for the complex and nested models respectively. We'll also importantly, need to specify the <code>lower.tail</code> argument. See <code>?pchisq</code>. 

```{r}
p_val <- pchisq(test_statistic, df = (4-3), lower.tail = FALSE)
p_val
```

So we see that the p-value here is lower than 0.05, so this essentially tells us that we have shown our more complex model is actually a <em>better</em> model for our data. 

### Akaike Information Criterion (AIC)

The AIC measure is of similar use to the LRT, but is slightly more flexible - it doesn't need two models that are nested, and is not based no a p-value. Also to note, is that the information criterion here is just one of a family of criteria that can be used for this purpose. 

The use of AIC is to calculate a measure for each in a set of candidate models, and then compare them. The goal is then to take the model with the lowest AIC value. We determine if two AIC values are sufficiently different by how far away the two models are in AIC. Say we take three toy models, 1, 2, and 3 each with a different subset of variables. We calculate the AIC for each, and then we actually are only interested in the $\Delta AIC$ (said "delta AIC"), wherein now the lowest $\Delta AIC$ value is 0, and the others are all in relation to that. Imagine the $\Delta AIC$ values for models 1, 2, and 3 are 1.5, 0.0, and 85.2. 

There is a rule of thumb that if a $\Delta AIC < 2$, then there is not a clear difference between models. In this case, we would pursue some other method to discern the path forward such as model-averaging (not discussed). If $2 < \Delta AIC < 10$ there is a sufficient difference between the two models, but other factors should be taken into account such as which model is more biologically realistic, or may contain a particular parameter of interest. In this case, model averaging or another comparison method may still be useful. If $\Delta AIC > 10$ then there is a clear difference and the model with >10 $\Delta AIC$ can be discarded. Note that these are all rules of thumb however, and not hard and fast rules. 

So for the example of $\Delta AIC$ values for models 1, 2, and 3 are 1.5, 0.0, and 85.2, we would discard the third model with $\Delta AIC = 85.2$, and likely pursue more sophistocated techniques to decide which of models 1 and 2 are to be kept.  

## Moving Beyond Simple Regression

So above we had a good example of the fundamentals of linear regression. That involved no transformations of data or anything of the sort. However, recall the first three assumptions of linear regression (linearity, homoskedasticity, and normality): these are very often not satisfied by the type of biological data we're likely to encounter in the "wild". To deal with this problem, we will, from here, abandon the simple linear model. 

## Generalized Linear Models (GLMs)

In a simple linear model, we expect the response variable varies in a linear fashion. That is, some constant amount of change in $X$ leads to a constant change in $Y$. We also need those two variables to be continuous and theoretically unbounded. But this is not always how real data behave!! For example, let's think about species richness. This is a zero-bounded integer value (not continuous!), but we are likely <strong>very</strong> interested in species richness for a variety of questions. Additionally, what about trying to model presence/absence data? Say we wanted to come up with a model for which the response variable is the presence or absence of a gene mutation in a lab rat? These two examples are not well described by a "continuous linear variable". What to do!! We shall simply abandon the linear model :)

The generalized linear model is the more flexible and useful big brother of the simple linear regression. It still uses regression techniques (i.e. fitting a line to some data), and often also uses a version of least squares methods, but adds a bit more complexity to the equation (literally and figuratively!).

These models always contain three things: 

1) A linear predictor 
2) A link function
3) A error distribution

This section is going to add two components - first the link function, and second, linear predictor. In the simple above example, we still had an error structure, but it corresponded to a normal distribution. Our linear predictor was also just a single value. As we move to talking about GLMs, we'll almost always consider multiple predictor variables in our models, as that's what usually makes sense biologically! 

Throughout this section on GLMs, we'll use the following example, which is an excellent example used by JJ Valletta and TJ McKinley in their "Statistical Modelling in R" book, and in Mick Crawley's "R Book": 

A long-term agricultural experiment had 90 grassland plots, each 25m x 25m, differing in biomass, soil pH and species richness (the count of species in the whole plot). The plots were classified according to a 3-level factor as high, medium or low pH with 30 plots in each level.

What are We interested in? Well, in many systems, species richness can be affected by biomass, usually negatively. In this grassland, what effect does biomass have on richness? Additionally, if there is a relationship between the two, does it differ across levels of soil pH? Let's set this out in some hypotheses: 

<strong>$H1_0$: Biomass has no effect on species richness. </strong>

<strong>$H2_0$: Differing pH has no effect on the relationship between species richness and biomass. </strong>

Now that we can anchor our thinking with this example, let's go back to the theory for a minute. <strong>I encourage the mathematically timid reader to NOT be afraid of the equations!! Take your time and read through them. We'll explain in detail and maybe you will actually find it fun!!</strong>

In the most basic terms, in a regression of this nature, we have some independent variable(s) $\bf{X}$, and a single dependent variable $\bf{Y}$. For every value of $\bf{X}$, we want to figure out the expected value of $\bf{Y}$. We write that like this: $$\text{E(}\bf{Y}|\bf{X})$$ which we would say as <em>"the expected value of $\bf{Y}$, conditional on $\bf{X}$"</em>

This expected value is then found as: $$\text{E}(\textbf{Y}|\textbf{X}) = \mu =g^{-1}(\textbf{X}\boldsymbol{\beta})$$

The term in the middle, $\mu$, is the mean of the probability distribution. Recall from that section that if $X$ is a random variable, then some expected value $Y$ is therefore going to be the mean of that distribution for that value of $X$. How do we get this mean value? Well, here we set it equal to the value on the righ-hand side.

The term on the right-hand side of the equation has two parts, $\textbf{X}\boldsymbol{\beta}$ is the <strong>linear predictor</strong> and the $g^{-1}()$ is the link function. We'll discuss the linear predictor first. 

### Linear Predictor

This is the value actually tells us how our response variable will change as our predictor variables change. Notice that here we're now talking about multiple predictor variables, as it's nearly always the case that a single variable will not be the only thing we're interested in. Introducing a few equations here will be useful. 

First of all, notice that both terms here ($\textbf{X}\boldsymbol{\beta}$) are bolded. That's because they're both actually vectors, that could contain multiple sets of $\text{X}$ predictor variables, and their associated $\beta$ values. So, to make this more clear, we'll call the linear predictor the Greek letter <em>eta</em>, $\eta$ instead. So we can state $\eta = \textbf{X}\boldsymbol{\beta}$. The exact calculation of $\eta$ is beyond the scope of the present discussion, so just know that when we have a bunch of predictor variables, and their unknown coefficients ($\beta$s), we end up with one single value $\eta$ that is passed to the link function. 

### Link Function 

This is the heart of what makes a model a GLM. This component essentially allows us to relax the assumption of normality of our response variable, by allowing other distributions, and then defining some function of the response variable that in fact DOES vary linearly with the predictor variables. The math behind how this works is both incredibly interesting, and requires some knowledge of linear algebra, so we will leave the interested reader with an encouragement to take a linear algebra class if they have room in their timetable. 

Suffice it to say here that a link function allows us to take some non-linear response data, and "transform" it such that it now varies linearly with the predictor variable(s). 

### Error Distribution

The error distribution we define will in turn define which link function we choose. Determining what error distribution we need to choose can be crudely but often satisfactorily chosen by plotting the response variable, but a more nuanced approach is possible. See <a href="https://r.qcbs.ca/workshop07/book-en/choose-an-error-distribution.html>this tutorial</a> from the Quebec Centre for Biodiversity Science for an example. 

### Species Richness Example - I

Back to our example stated earlier regarding if the relationship between biomass and species richness changes with soil pH. The data for this example can be found <a href="https://exeter-data-analytics.github.io/StatModelling/_data/species.csv">here</a>. If you want to download the data and follow along, be sure to check out the <a href="../01-basicr/01-06-workflow.html">Workflow section</a>. 

Since we already have our hypothesis stated (and therefore cannot p-hack ourselves), we can proceed to plot our data. Let's first inspect it briefly:

```{r}
library(tidyverse)
# uncomment and edit the lines below if you need to read in the data 
# library(here)
# df <- readr::read_csv(here("./data/species.csv"))

# quick summary of our data
dplyr::glimpse(df)
head(df)
```

Ok so we can see what types are data are. It's important here to not be tricked by R!! It has read in the data automatically with the <code>Species</code> column as numeric type, but it's in fact integer values. This doens't matter right now, but it will matter when we need to choose an error distribution. 

#### Step 1 - Plot Data

Let's plot our data to see about what we're dealing with. 

```{r}
library(ggthemes)

ggplot(data = df) + 
  geom_point(mapping = aes(x = Biomass, y = Species)) +
  ggthemes::theme_base()
```

It even looks like there's a linear decrease in richness as biomass increases. So why can't we just assume a normal distribution here? Well, let's take a look at it. 

#### An Aside - Motivation for Link Functions

If we simply assume a Normal distribution, we don't even need to specify a link function. I'm going to fit the model and plot the result, with the code behind the scenes so it's super clear this is NOT what you're supposed to do, as a demonstration. 

```{r, echo=FALSE}
# fit model using glm()
fit = glm(Species ~ Biomass,
  data = df,
  family = gaussian(link = "identity"))
df$pH = as.factor(df$pH)
newdata = expand.grid(Biomass = seq(min(df$Biomass), max(df$Biomass),
                                    length.out = 200))
newdata_predict = cbind(newdata,
                        Species = predict(fit, newdata, type = "response"))

# now make our plot
ggplot(data = df, aes(x = Biomass, y =Species)) +
  geom_point() +
  geom_line(data = newdata_predict, colour = "red") + 
  ggthemes::theme_base()
```

Here, the lines are representing the fitted regression lines, with the predicted values of species richness for each value of biomass. What's wrong with this? Well nothing yet! But often when we do this type of regression, we want to predict out of sample, or essentially figure out what will happen at levels of our predictor variable we haven't observed. Let's do that here: 

```{r}
newdata = expand.grid(Biomass = seq(min(df$Biomass), 30,
                                    length.out = 200))
newdata_predict = cbind(newdata,
                        Species = predict(fit, newdata, type = "response"))

# now make our plot
ggplot(data = df, aes(x = Biomass, y =Species)) +
  geom_point() +
  geom_line(data = newdata_predict, colour = "red") + 
  ggthemes::theme_base()
```

So we want to predict out of sample. We've done that! We can now make a guess at what values of Species Richness would be present at a Biomass value of 30. But what's wrong with <strong>this</strong> one? 

<strong>We're predicting NEGATIVE species richness</strong>. That's impossible! We can probably guess that as biomass gets higher, we'll actually probably have something more like an asymptotic decline of species richness. So how can we model this? <strong>A link function</strong>. 

#### Step 2 - Error Distribution

Now that we know we need to use a link function to appropriately deal with our data, we will start the process of finding that function by figuring out what type of error distribution our response data have.  

Let's use our crude by satisfactory method of choosing an error distribution, via plotting our response variable. We can do this a couple ways. As a density plot:

```{r}
ggplot(data = df, mapping = aes(x = Species)) + 
  geom_density(fill = "goldenrod2", alpha = 0.3) +
  ggthemes::theme_base()
  
```

Or perhaps as a histogram: 

```{r}
ggplot(data = df, mapping = aes(x = Species)) + 
  geom_histogram(fill = "blue2", colour = "black", alpha = 0.3,
                 bins = 30) +
  ggthemes::theme_base()
```

What to do? Well, this follows a slightly skewed distribution, but it's discrete integer-valued. For this purpose, a Poisson distribution will work well. 

#### Step 3 - Selecting a Link Function 

We have to come up with a function that will allow us to continue. We can see which link functions are supported for the different distributions in the <code>stats</code> package:

```{r}
?family
```

And a helpful page will pop up. The beginning of the help page has the following info: 

<img src="../img/04-img/family.png">

<strong>And we can see that for the Poisson distribution, we must use the log link function.</strong>

Previously we were interested in $\mu$ to get our expected value of $\text{E(}\bf{Y}|\bf{X})$ but we need to come up with some way to link to $\mu$. It turns out that in this case, our $\textbf{X}\boldsymbol{\beta}$ can be restated as $\textbf{X}\boldsymbol{\beta} = \text{ln}(\mu)$, so in this case, $$\text{E(}\textbf{Y}|\textbf{X}) = \text{exp}(\textbf{X}\boldsymbol{\beta})$$, because we may recall from math class that the exponential function is the natural logarithm. 

#### Step 4 - Fitting the Model 

Okay, let's (Finally!) fit the model. Turns out, yet again, that it's dead simple in R. 

```{r}
mod_poi <- stats::glm(Species ~ Biomass,
                      data = df,
                      family = poisson(link = log))
```

And we can look at the output here: 

```{r}
summary(mod_poi)
```

The output here is very similar to that of <code>lm()</code>, but we'll walk through it en entirety in a second. First however, let's check our model is performing well enough: 

#### Step 5 - Model Evaluation

We need to make sure that our model is agreeing with all our assumptions, and also that it's doing a good-enough job. Model evaluation and validation is actually very involved for more complicated models, but for our simple model, let's first plot our residuals against out fitted values and a QQ plot. We can do that by simply calling <code>plot()</code> on our model object. 

```{r}
par(mfrow = c(2,2)) # this will put the plots in a grid
plot(mod_poi)
```

This calls 4 plots, but we will only look at the first two for now. We see the line of the residuals and fitted values is straight and mostly follows the dotted line, and the QQ plot also follows the diagonal line sufficiently well. These quick diagnostics let us know we can continue.

For more on model evaluation, there's great texts out there, but I like Laurie Tupper's chapter on <a href="https://bookdown.org/ltupper/340f21_notes/m5-model-evaluation.html">Model Evaluation</a> as a gentle introduction.

#### Step 6 - Interpreting the Output

Let's re-call the output here:

```{r}
summary(mod_poi)
```

This output has a number of components.

1. <strong>Call</strong> -- this is the function we used in our model. So to recall, what we're showing here is the that we've regressed <code>Species ~ Biomass</code> which we would say as "species richness regressed against biomass" or "species richness regressed with biomass". 

2. <strong>Deviance Residuals</strong> -- Previously we were talking about just plain old residuals, which is for a single value of x, the distance between the predicted value on the regression line, and the observed value of y. <strong>Deviance</strong> by itself, is a measure of goodness of fit, wherein the smaller the value, the better the fit of the model and vice versa. Describing the calculation of a Deviance Residual is beyond the current scope, but we can still interpret similarly to residuals, in that if a singular point has a high deviance residual, then it's far from our predicted value. 

3. <strong>Coefficients</strong> -- Possibly the part that we'll look at the most, these values are here shown as representing $\beta_0$ and $\beta_1$. So the intercept is the actual y-intecept (remember that $\beta_0$ is the y-intercept), and the $\beta_1$ is the estimate of the coefficient on $Biomass$. It's good to think about whether or not the y-intercept makes sense to interpret. Recall that the intercept value here is the predicted value of species richness if the biomass is zero. In some cases that might be a useful interpretation, but there can't really be any species richness without them having a biomass, so it's not a super useful value in our case. 

In our case, the coefficient for <code>Biomass</code> is -0.064. This is the slope relating <code>Biomass</code> to the predicted <strong>log</strong> of the species richness. Why log? Well, because we've used a log link function. This is actually a really important point as it means our interpretation is not straight forward. In this example, if we have a grassland plot (Plot A) with a predicted (i.e. the value on the regression line) value $s$, and Plot B has a predicted count of one unit higher, how many more species do we actually predict? If Plot A has predicted number of species $s$, then it actually has a log count of $\text{log}(s)$, and Plot B has a predicted number of species $\text{log}(s) - 0.064$. So how many <em>actual</em> species are there in Plot B compared to Plot A? The inverse of the log we'll recall is the exponential function, so we can get the inverse of $\text{log}(s) - 0.064$, to get $\hat{\lambda}_B$ with: $$\hat{\lambda} = e^{\text{log}(s) - 0.064}$$ which is rewritten as $$\hat{\lambda} = e^{\text{log}(s)} * e^\text{-0.064}$$ which we then can see will simplify to $$s * 0.938005$$. So the amount of species in Plot B is actually ~0.94 <em>multiplied</em> by $s$. This makes sense, as since we employed a log link function, an increase or decrease in the predictor variable has not an additive but multiplicative effect on the response variable. 

<strong>Hint:</strong> What if you don't want to calculate that every time?? Don't worry, we'll talk about how to do it in R easily, next. 

Also note here that the test statistic is actually a z-value instead of a t-value from the <code>lm()</code>. The significance is interpreted as before. 

4. <strong>Null vs. Residual Deviance</strong> -- The deviance of the null model is the amount of deviance in a model fitting just the intercept, $\beta_0$. The residual deviance is the deviance of the model you're currently using. If the deviance of the null model is low, it means that just the intercept is doing a good job, so you don't likely need to or want to add a large number of predictor variables. The residual deviance being lower means that the model you're using is appropriately better than just the intercept. 

5. <strong> AIC </strong> -- Beyond the current scopt to address in sufficient detail, just know that the AIC value is meaningless for just a single model. In fact, this value tells us next to nothing. It is in fact used to compare multiple models to see which model best explains the data. With multiple models, we would compare the AIC values, and the lowest AIC value would be considered the "best" model. 

#### Step 6 - Prediction & Conclusions

Just this model by itself is not incredibly useful, we likely want to plot some predicted values, like the plot above, but now using the proper link function. Recall how from #3 above, we had the tedious task of doing math (heaven forbid!) to find some response values. Let's not do that, but instead ask R to do it for us. We can do this from the <code>predict()</code> function from the <code>stats</code> package. It will take in our fitted model, and some predictor data values, and predict the response value for us. Let's do that now first by just plotting the regression line in-sample (i.e. in the range of biomass values we have data for). Note that to get the "response" value, we need to pass <code>type = "response"</code> to the function. 

Typically the best way to do this is make our prediction and bind that to our original dataframe so we have the real observed values of our response variable alongside the predicted ones for plotting. The best way to do that is through a call to <code>mutate()</code> from <code>dplyr</code>.

```{r}
df_pred <- df %>% 
  dplyr::mutate(
    Species_pred = stats::predict(mod_poi, type = "response")
  )

# now bind this new dataframe to our old dataframe 
```

And now we can plot from this new dataframe: 

```{r}
ggplot(data = df_pred) + 
  # plot the observed points
  geom_point(aes(x = Biomass, y = Species), 
             colour = "black", fill = "purple", shape = 21) + 
  # plot regression line
  geom_line(aes(x = Biomass, y = Species_pred), 
             colour = "red", size = 1.2) + 
  ggthemes::theme_base()
  
```

"But wait! That line isn't straight??" True, because we're using a link function to relate our data linearly, but accomodate for non-linearity :) 

Now, if we want to predict <em>out</em> of our sampled data, we could use the predict function again in a new way, by creating a new dataset with some extended Biomass data and the predicted species data. However, this time because we're predicting out of sample, we need to make use of the <code> newdata</code> argume in <code>predict()</code> to tell R which values to use the model to predict across. There's a few requirements. It needs to be passed a dataframe, with columns with the same names as the predictor variables in the model fit formula originally.

```{r}
# make a dataframe with just the two variables
df_pred_out <- data.frame(
  # make a sequence from our minimum observed amount out to 30 
  Biomass = seq(min(df$Biomass), 30, 0.1), 
  Species = stats::predict(mod_poi, 
                           newdata = data.frame(
                             Biomass = seq(min(df$Biomass), 30, 0.1)
                             ),
                           type = "response")
)

head(df_pred_out)
```

And the plot: 

```{r}
ggplot(data = df_pred_out) + 
  # plot regression line
  geom_line(aes(x = Biomass, y = Species), 
             colour = "red", size = 1.2) + 
  ggthemes::theme_base() + 
  labs(y = "Predicted Species Richness")
  
```

And here we go! We've finally showed, visually, why we need a link function! We can now predict out to a higher than observed biomass without predicting unrealistic response variable values. 

Whether our question required making a prediction plot out of sample or not (ours likely didn't, we probably can suffice with just the first plot of predictions), it's now time to figure out if we've answered our question. Our null hypothesis was there was no effect of biomass on species richness. We can confidently say that we reject this null hypothesis, given the output above. 

### Species Richness Example - II

Recall that at the beginning of the previous section, we asked if biomass affected species richness, but <em>also</em> if that was the case, if that effect differed across levels of pH. Here our $H_0$ will be that the relationship between Biomass and Species richness does not differ across levels of pH. 

So that means we're asking about the <em>interaction</em> between Biomass and pH. <strong>It's important to know that in R, there are two ways to specify an interaction between two variables, $X_1$ and $X_2$.</strong> The more common way is to use <code> y ~ x1*x2</code>, but what this does mathematically? It turns out in that case, we are in fact fitting a model that looks for an effect of both variables individually, as well as their interaction, which in an R implementation would be equivalent to writing <code>y ~ x1 + x2 + x1*x2</code>  which we can easily see is a more complicated model than just the interaction. To specify <em>just</em> the interaction, we would instead write <code>y ~ x1:x2</code>. Now there's nothing wrong with either of these, but it's important to know which one we're selecting, and <em>why</em> we're selecting that one. 

We'll take a moment here and discuss what an interaction means mathematically. In our context we're using pH. 

```{r}
unique(df$pH)
```

This is a categorical variable with three levels. What does that mean? Well, if we think back to when we talked about categorical variables in the linear model section, we talked about indicator functions. We'll actually use the same concept here. In this case, we'll create three indicator variables, one for each. So in essence for the model with just the interaction, we're fitting this model: $$\hat{Y} = \beta_0 + \beta_1\text{pH-LOW}*\text{Biomass} + \beta_2\text{pH-MED}*\text{Biomass} + \beta_3\text{pH-HI}*\text{Biomass}$$ so here we're fitting an intercept and three beta values, one for the interaction of each level of the pH and the biomass. So if we have a new level of biomass and we want to know the species richness, we actually cannot answer that unless we also know the pH. 

For the model that estimates the effect of both variables and their interaction, we (or rather, R), will use one of the levels of our categorical variable as the intercept. In this case, let's assume it takes the "High" pH treatment. So then, we'll use two indicator variable that essentially say: 

$$I_{low} = 
\begin{cases}
1 & \text{if pH value is "low"}\\
0 & \text{otherwise}\\
\end{cases}
$$ 
and 

$$I_{mid} = 
\begin{cases}
1 & \text{if pH value is "mid"}\\
0 & \text{otherwise}\\
\end{cases}
$$ 

so our model will end up looking like: 

$$\hat{Y} = \beta_0 + \beta_{biomass}*Biomass + \beta_{low}*I_{low} + \beta_{med}*I_{mid} + \beta_{BL}*Biomass*I_{low} + \beta_{BM}*Biomass*I_{med} $$

For us, we'll use our model comparison and evaluation metrics from the Linear Regression section. The idea will be to take our variables of interest and compare three different models for species richness ($Y$): 1) model with just biomass, 2) model with just the interaction between biomass and pH, and 3) pH, biomass, and their interaction. We'll compare our three models, and evaluate which is best. 

We'll essentially walk through all the steps from section I, but fitting each of our models.

#### Step 1 - Plot data

Let's plot our data again, but this time, since our other variable of interest is pH, we'll look at that as well. 

First, what values does pH take? 

```{r}
unique(df$pH)
```

Okay, let's colour our points by those levels: 

```{r}
ggplot(data = df) + 
  geom_point(mapping = aes(x = Biomass, y = Species, fill = pH),
             shape = 21, colour = "black", size = 3) +
  ggthemes::theme_base()
```

Ok so there's a very obvious pattern here!!

#### Step 2 & 3 

We already did this above in the first walk through section, but a poisson distribution with a log link function is sufficient for our purposes here. 

#### Step 4 - Fit the Model 

Now, we need to fit three separate models, so we'll go from least to most complicated: 

```{r}
mod1 <- stats::glm(Species ~ Biomass,
                   data = df,
                   family = poisson(link = log))
mod2 <- stats::glm(Species ~ Biomass:pH,
                   data = df,
                   family = poisson(link = log))
mod3 <- stats::glm(Species ~ Biomass*pH,
                   data = df,
                   family = poisson(link = log))

```

Since we are doing model comparison, we first want to figure out which model does the best job, and then only bother looking at the results for the best one. 

#### Step 5 - Model Evaluation 

So let's do this in a particular way. We'll calculate the negative log-likelihood for each model, since, because our models are nested, we can actually do two Likelihood Ratio Tests, which we discussed in the Linear Regression section. 

First we'll extract the log-likelihoods for each
```{r}
mod1_LL <- stats::logLik(mod1)
mod2_LL <- stats::logLik(mod2)
mod3_LL <- stats::logLik(mod3)
```

Now, since we have two comparisons to make, we'll calculate the test statistic first for models 1 and 2:

```{r}
teststat_mod1_2 <- test_statistic <- -2 * (as.numeric(mod1_LL) - 
                          as.numeric(mod2_LL))
```

And now we can get the p-value that adding the additional parameter improved the model. Note that we can extract the degrees of freedom, which we need for our test, can be extracted from the model itself. If a model object is called <code>mod</code> then the degrees of freedom for our purposes can be extracted with <code>summary(mod)$df[1]</code>:
```{r}
deg_f_1 <- summary(mod1)$df[1]
deg_f_2 <- summary(mod2)$df[1]
deg_f_3 <- summary(mod3)$df[1]

# calculate p-value
p_val_mod1_2 <- pchisq(teststat_mod1_2, 
                       df = (deg_f_2 - deg_f_1), 
                       lower.tail = FALSE)
p_val_mod1_2
```

Ok, so definitely <0.05, and we can move to our next comparison, between the interaction model, and the model with the variables included. We'll again get our test statistic: 

```{r}
teststat_mod2_3 <- test_statistic <- -2 * (as.numeric(mod2_LL) - 
                          as.numeric(mod3_LL))
```

And now we can get the p-value: 

```{r}
# calculate p-value
p_val_mod2_3 <- pchisq(teststat_mod2_3, 
                       df = (deg_f_3 - deg_f_2), 
                       lower.tail = FALSE)
p_val_mod2_3
```

Again, a small p-value, so we can see that in fact this most complex model offers the best combination of variables. If we wanted to, we could also check the AIC values for each model: 

```{r}
AIC(mod1)
AIC(mod2)
AIC(mod3)
```

Ok, so if we're following our rules of thumb, then we have a clear best model - the third and most complex model. So now, we can move on to interpreting!

#### Step 6 - Interpreting the Output

So let's look at the summary of our model of choice: 

```{r}
summary(mod3)
```

So we can see here the output as we're used to seeing. However, recall, to make easy direct comparisons, we need to think about these values as relating to the predicted <strong>log</strong> of the species richness. 

It's easiest to conceptualize as thinking about predicting a value of species richness (since that what the whole model is supposed to do), given some information. With the information above, let's re-state our full model with the $\beta$ values plugged in: 

$$\hat{Y} = 3.77 - 0.11*Biomass - 0.82*I_{low} - 0.33*I_{med}  - 0.16*Biomass*I_{low} - 0.03*Biomass*I_{med} $$

So to get the estimated number of species $\hat{Y}$, we require at least two pieces of data: 1) the pH level, and 2) the biomass value. So let's assume the biomass is something like 7.5, and the pH level is medium. What will our equation simplify to? Well, let's plug in our values for our biomass and the indicator functions: 

$$\hat{Y} = 3.77 - 0.11*Biomass - 0.82*0 - 0.33*1.0  - 0.16*Biomass*0 - 0.03*Biomass*1.0 $$

Now obviously the terms with a zero being multiplied will go to zero, and the others can be simplified:

$$\hat{Y} = 3.77 - 0.11*Biomass - 0 - 0.33*1.0  - 0 - 0.03*Biomass $$
And now we can simplify each term: 

$$\hat{Y} = 3.77 - 0.11*Biomass - 0.33  - 0.03*Biomass $$

Which gives us the value of: 

$$\hat{Y} = 3.44 - 0.14*Biomass$$

or

$$\hat{Y} = 3.44 - 0.14*7.5 = 2.39$$

Now recall this is on the log scale!! So how do we get it in terms of the number of species? 

$$\hat{Y} = e^{2.39} \approx 10.91$$

### Step 6 - Interpreting the Results 

<strong>As a quick sanity check - when we plot this in this step, how many prediction/regression lines will there be?</strong>

So we've done some of the interpretation already, but specifically with respect to our answer above of how many species we should expect under medium pH conditions and with a biomass value of 7.5, let's check if our answer agrees with R. To do this, we'll recall the <code>predict()</code> function from the <code>stats</code> package:

```{r}
# make a dataframe with a single observation
new_df <- data.frame(Biomass = 7.5, pH = "mid")

# now predict
stats::predict(mod3, newdata = new_df, type = "response")
```

And we can see that our answers agree! But we likely want to make some <strong>biological</code> interpretations. So let's make a plot of our results overall. 

```{r}
# make new data to regress against -- use expand.grid()
new_df_full <- expand.grid(Biomass = seq(min(df$Biomass), max(df$Biomass),
                                         length.out = 200),
                           # note that pH has to be a factor here
                           pH = levels(as.factor(df$pH)))

# make model predictions
mod_pred <- stats::predict(mod3, 
                           newdata = new_df_full,
                           type = "response")

# bind to a dataframe
predict_df <- data.frame(
  cbind(new_df_full, 
        Species = mod_pred)
)
head(predict_df)
```

Now let's make the plot: 

```{r}
ggplot() + 
  geom_point(data = df, aes(x = Biomass, y = Species, fill = pH),
             shape = 21, size = 3) + 
  geom_line(data = predict_df, aes(x = Biomass, y = Species, colour = pH),
            size = 1.3) + 
  ggthemes::theme_base()
```

If we felt like it, we could change this to make it slightly more nice. First, let's put the lines behind the points. We'll also re-order the levels of the factor so the legend reads high, mid, low. 

```{r}
# re-level the factors
predict_df$pH = factor(predict_df$pH, levels = c("high", "mid", "low"))
df$pH = factor(df$pH, levels = c("high", "mid", "low"))

ggplot() + 
    geom_line(data = predict_df, aes(x = Biomass, y = Species, colour = pH),
            size = 1.3) + 
  geom_point(data = df, aes(x = Biomass, y = Species, fill = pH),
             shape = 21, size = 3) + 
  ggthemes::theme_base() 
```

And we're done! 